<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bird Animation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
        }

        body, html {
            height: 100%;
        }

        canvas {
            position: absolute;
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <script src="https://unpkg.com/browse/@esotericsoftware/spine-webgl@4.2.61/dist/iife/spine-webgl.js"></script>
    <script>
        let canvas, ctx, shader, batcher, mvp, skeletonRenderer, assetManager;
        let lastFrameTime, skeleton, animationState, bounds;

        function init() {
            canvas = document.getElementById("canvas");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const config = { alpha: true }; // Enable transparency
            ctx = new spine.ManagedWebGLRenderingContext(canvas, config);

            if (!ctx.gl) {
                alert("WebGL is unavailable.");
                return;
            }

            shader = spine.Shader.newTwoColoredTextured(ctx);
            batcher = new spine.PolygonBatcher(ctx);
            mvp = new spine.Matrix4();
            mvp.ortho2d(0, 0, canvas.width - 1, canvas.height - 1);

            skeletonRenderer = new spine.SkeletonRenderer(ctx);
            assetManager = new spine.AssetManager(ctx, "https://metodisokolov.github.io/falkonanim/bird/");

            // Load assets for bird animation (corrected URLs)
            assetManager.loadText("https://metodisokolov.github.io/falkonanim/bird/bird_export.json");
            assetManager.loadText("https://metodisokolov.github.io/falkonanim/bird/bird_export.atlas");
            assetManager.loadTexture("https://metodisokolov.github.io/falkonanim/bird/bird_export.png");

            requestAnimationFrame(load);
        }

        function load() {
            if (assetManager.isLoadingComplete()) {
                loadSkeleton("https://metodisokolov.github.io/falkonanim/bird/bird_export.json", "loop1", true); // Loop1 animation will play
                lastFrameTime = Date.now() / 1000;
                requestAnimationFrame(render);
            } else {
                requestAnimationFrame(load);
            }
        }

        function loadSkeleton(name, initialAnimation, premultipliedAlpha) {
            let atlas = assetManager.require(name.replace(".json", ".atlas"));
            let atlasLoader = new spine.AtlasAttachmentLoader(atlas);
            let skeletonLoader = new spine.SkeletonJson(atlasLoader);

            skeletonLoader.scale = 1;
            let skeletonData = skeletonLoader.readSkeletonData(assetManager.require(name));
            let skeleton = new spine.Skeleton(skeletonData);
            skeleton.setSkinByName("default");

            let animationStateData = new spine.AnimationStateData(skeleton.data);
            let animationState = new spine.AnimationState(animationStateData);

            // Set the 'loop1' animation instead of the default one
            animationState.setAnimation(0, "loop1", true);  // Loop1 will play

            let bounds = calculateSetupPoseBounds(skeleton);

            return {
                skeleton: skeleton,
                state: animationState,
                bounds: bounds,
                premultipliedAlpha: premultipliedAlpha
            };
        }

        function calculateBounds(skeleton) {
            skeleton.setToSetupPose();
            skeleton.updateWorldTransform();
            const offset = new spine.Vector2();
            const size = new spine.Vector2();
            skeleton.getBounds(offset, size, []);
            return { offset, size };
        }

        function render() {
            const gl = ctx.gl;
            const now = Date.now() / 1000;
            const delta = now - lastFrameTime;
            lastFrameTime = now;

            resizeCanvas();

            gl.clearColor(0.0, 0.0, 0.0, 1);
            gl.clear(gl.COLOR_BUFFER_BIT);

            animationState.update(delta);
            animationState.apply(skeleton);
            skeleton.updateWorldTransform();

            shader.bind();
            shader.setUniformi(spine.Shader.SAMPLER, 0);
            shader.setUniform4x4f(spine.Shader.MVP_MATRIX, mvp.values);

            batcher.begin(shader);
            skeletonRenderer.premultipliedAlpha = true;
            skeletonRenderer.draw(batcher, skeleton);
            batcher.end();

            shader.unbind();
            requestAnimationFrame(render);
        }

        function resizeCanvas() {
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;

            if (canvas.width !== width || canvas.height !== height) {
                canvas.width = width;
                canvas.height = height;
            }

            const centerX = bounds.offset.x + bounds.size.x / 2;
            const centerY = bounds.offset.y + bounds.size.y / 2;
            const scale = Math.max(bounds.size.x / width, bounds.size.y / height) * 1.5;

            const scaledWidth = width * scale;
            const scaledHeight = height * scale;

            mvp.ortho2d(centerX - scaledWidth / 2, centerY - scaledHeight / 2, scaledWidth, scaledHeight);
            ctx.gl.viewport(0, 0, width, height);
        }

        init();
    </script>
</body>
</html>
